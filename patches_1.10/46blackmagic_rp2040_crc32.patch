diff --git a/src/target/rp2040.c b/src/target/rp2040.c
index ffb11fce..466916e0 100644
--- a/src/target/rp2040.c
+++ b/src/target/rp2040.c
@@ -203,6 +203,8 @@ static void rp_flash_enter_xip(target_s *target);
 static void rp_flash_connect_internal(target_s *target);
 static void rp_flash_flush_cache(target_s *target);
 
+static bool rp_crc32(target_s *target, target_addr32_t start_address, size_t size, uint32_t *crc32);
+
 static void rp_add_flash(target_s *target)
 {
 	const bool por_state = rp_flash_in_por_state(target);
@@ -248,6 +250,7 @@ bool rp2040_probe(target_s *const target)
 	target->target_storage = (void *)priv_storage;
 
 	target->driver = "RP2040";
+	target->crc32 = rp_crc32;
 	target->target_options |= TOPT_INHIBIT_NRST;
 	target->attach = rp_attach;
 	target->enter_flash_mode = rp_flash_prepare;
@@ -729,3 +732,44 @@ bool rp2040_rescue_probe(adiv5_access_port_s *ap)
 
 	return true;
 }
+
+#include "../../../blackmagic_addon/flashstub/rp2040_crc32.stub"
+#define RP_CRC_STUB_ADDR 0x20000000
+//#define RP_CRC_STUB_ADDR 0x20040000 // scratch
+
+void *bmp_get_temporary_buffer(uint32_t asked);
+
+/*
+  * if it returns false, we use the "normal" crc32
+  *
+  */
+bool rp_crc32(target_s *target, target_addr32_t start_address, size_t size, uint32_t *crc32)
+{
+	bool ret = false;
+	uint8_t *rp_crc32_buf = bmp_get_temporary_buffer(RP2040_CRC32_BIN_LEN);
+	if (size < 300)
+		return false; // if it is small it's not worth it
+	// is the area we are CRCing collides with the stub ?
+	if ((start_address >= RP_CRC_STUB_ADDR) && (start_address < RP2040_CRC32_BIN_LEN + RP_CRC_STUB_ADDR))
+		return false;
+	if ((start_address <= RP_CRC_STUB_ADDR) && (start_address + size) > RP_CRC_STUB_ADDR)
+		return false;
+	// not aligned
+	if (start_address & 3)
+		return false;
+	if (size & 3) // TODO FIXME we can deal with that
+		return false;
+	// Step1 : copy the ram to a temp buffer
+	target_mem32_read(target, rp_crc32_buf, RP_CRC_STUB_ADDR, RP2040_CRC32_BIN_LEN);
+	// step2 : Upload the stub
+	target_mem32_write(target, RP_CRC_STUB_ADDR, rp2040_crc32_bin, RP2040_CRC32_BIN_LEN);
+	// step3 : run the stub
+	if (!cortexm_run_stub(target, RP_CRC_STUB_ADDR + 1, start_address, size >> 2, 0, 0)) {
+		target->reg_read(target, 1, crc32, 4); // oytput in r1
+		ret = true;
+	}
+	// step4 : replace the ram
+	target_mem32_write(target, RP_CRC_STUB_ADDR, rp_crc32_buf, RP2040_CRC32_BIN_LEN);
+done_and_done:
+	return ret;
+}

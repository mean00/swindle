diff --git a/src/target/flashstub/riscv32_flashstub.h b/src/target/flashstub/riscv32_flashstub.h
new file mode 100644
index 00000000..0e79eb8a
--- /dev/null
+++ b/src/target/flashstub/riscv32_flashstub.h
@@ -0,0 +1,10 @@
+#pragma once
+
+/*
+ * exit stub, 0  means OK, else error code
+ */
+static inline void __attribute__((always_inline)) riscv_stub_exit(const int code)
+{
+	__asm__("li a0, %0 \n"
+			"ebreak" ::"i"(code));
+}
diff --git a/src/target/riscv32.c b/src/target/riscv32.c
index 365126cf..12f7a60e 100644
--- a/src/target/riscv32.c
+++ b/src/target/riscv32.c
@@ -666,3 +666,92 @@ static int riscv32_breakwatch_clear(target_s *const target, breakwatch_s *const
 	const uint32_t address = 0;
 	return riscv_config_trigger(hart, breakwatch->reserved[0], RISCV_TRIGGER_MODE_UNUSED, &config, &address) ? 0 : -1;
 }
+
+#define RISCV_REG_A0 10
+#define RISCV_REG_A1 11
+#define RISCV_REG_A2 12
+#define RISCV_REG_A3 13
+#define RISCV_REG_PC 32
+#define RISCV_REG_SP 2
+
+/*
+    Small helper function to translate target to hart and simplify parameters
+    We assume it is 32 bits
+*/
+static bool riscv32_target_csr_write(target_s *target, const uint16_t reg, uint32_t val)
+{
+    riscv_hart_s *const hart = riscv_hart_struct(target);
+    return riscv_csr_write(hart, reg, &val);
+}
+
+/*
+    Small helper function to translate target to hart and simplify parameters
+    We assume it is 32 bits
+*/
+static bool riscv32_target_csr_read(target_s *target, const uint16_t reg, uint32_t *val)
+{
+    riscv_hart_s *const hart = riscv_hart_struct(target);
+    return riscv_csr_read(hart, reg, val);
+}
+
+/*
+    Execute code on the target with the signature void function(a,b,c,d)
+        - codexec is the address the code to tun is located at
+        - param1/2/3/4 will end up as the 4 parameters of the stub function
+
+    The flashstub must not use the stack at all.
+    It returns true on success, false on error
+    There is a built-in timeout of 10 seconds
+*/
+bool riscv32_run_stub(target_s *t, uint32_t codeexec, uint32_t param1, uint32_t param2, uint32_t param3,
+                      uint32_t param4)
+{
+    bool ret = false;
+    uint32_t pc, mie, zero = 0;
+    // save PC & MIE
+    t->reg_read(t, RISCV_REG_PC, &pc, 4);
+    riscv32_target_csr_read(t, RV_CSR_MIE, &mie);
+    riscv32_target_csr_write(t, RV_CSR_MIE, zero); // disable interrupt
+    t->reg_write(t, RISCV_REG_A0, &param1, 4);
+    t->reg_write(t, RISCV_REG_A1, &param2, 4);
+    t->reg_write(t, RISCV_REG_A2, &param3, 4);
+    t->reg_write(t, RISCV_REG_A3, &param4, 4);
+    t->reg_write(t, RISCV_REG_PC, &codeexec, 4);
+
+    target_halt_reason_e reason = TARGET_HALT_RUNNING;
+    t->halt_resume(t, false); // go!
+    platform_timeout_s timeout;
+    platform_timeout_set(&timeout, 10000);
+    while (reason == TARGET_HALT_RUNNING)
+    {
+        if (platform_timeout_is_expired(&timeout))
+        {
+            goto the_end;
+        }
+        reason = t->halt_poll(t, NULL);
+    }
+
+    if (reason == TARGET_HALT_ERROR)
+    {
+        goto the_end;
+    }
+
+    if (reason != TARGET_HALT_REQUEST)
+    {
+        goto the_end;
+    }
+    ret = true;
+the_end:
+    t->halt_request(t);
+    if (ret)
+    {
+        uint32_t a0;
+        t->reg_read(t, RISCV_REG_A0, &a0, 4);
+        ret = (a0 == 0);
+    }
+    // restore PC & MIE
+    riscv32_target_csr_write(t, RV_CSR_MIE, mie); // put back MIE
+    t->reg_write(t, RISCV_REG_PC, &pc, 4);
+    return ret;
+}
+//----
diff --git a/src/target/riscv_debug.h b/src/target/riscv_debug.h
index 8af394a7..65729ee4 100644
--- a/src/target/riscv_debug.h
+++ b/src/target/riscv_debug.h
@@ -234,4 +234,15 @@ uint32_t riscv32_pack_data(const void *src, uint8_t access_width);
 void riscv32_mem_read(target_s *target, void *dest, target_addr_t src, size_t len);
 void riscv32_mem_write(target_s *target, target_addr_t dest, const void *src, size_t len);
 
+/*
+    Execute code on the target with the signature void stub_function(a,b,c,d)
+        - codexec is the address the code to run is located at
+        - param1/2/3/4 will end up as the 4 parameters of the stub function
+        
+    The flashstub must not use the stack at all.
+    The flashstub must return 0 on success, not 0 on error
+    There is a built-in timeout of 10 seconds
+*/
+bool riscv32_run_stub(target_s *target, uint32_t loadaddr, uint32_t a0, uint32_t a1, uint32_t a2, uint32_t a3);
+
 #endif /*TARGET_RISCV_DEBUG_H*/

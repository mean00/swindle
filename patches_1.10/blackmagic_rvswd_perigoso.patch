diff --git a/src/command.c b/src/command.c
index f77149b..9b8f584 100644
--- a/src/command.c
+++ b/src/command.c
@@ -46,6 +46,7 @@
 #include "traceswo.h"
 #endif
 
+/*static  */ bool cmd_rvswd_scan(target_s *target, int argc, const char **argv);
 static bool cmd_version(target_s *t, int argc, const char **argv);
 static bool cmd_help(target_s *t, int argc, const char **argv);
 
@@ -82,6 +83,7 @@ const command_s cmd_list[] = {
 	{"jtag_scan", cmd_jtag_scan, "Scan JTAG chain for devices"},
 	{"swd_scan", cmd_swd_scan, "Scan SWD interface for devices: [TARGET_ID]"},
 	{"swdp_scan", cmd_swd_scan, "Deprecated: use swd_scan instead"},
+	{"rvswdp_scan", cmd_rvswd_scan, "Scan RVSWD (WCH Risc-V) for devices"},
 	{"auto_scan", cmd_auto_scan, "Automatically scan all chain types for devices"},
 	{"frequency", cmd_frequency, "set minimum high and low times: [FREQ]"},
 	{"targets", cmd_targets, "Display list of available targets"},
@@ -689,3 +691,50 @@ static bool cmd_heapinfo(target_s *t, int argc, const char **argv)
 		gdb_outf("%s\n", "Set semihosting heapinfo: HEAP_BASE HEAP_LIMIT STACK_BASE STACK_LIMIT");
 	return true;
 }
+
+
+ 
+ bool cmd_rvswd_scan(target_s *target, int argc, const char **argv)
+ {
+ 	(void)target;
+ 	(void)argc;
+ 	(void)argv;
+ 
+ 	if (platform_target_voltage())
+ 		gdb_outf("Target voltage: %s\n", platform_target_voltage());
+ 
+ 	if (connect_assert_nrst)
+ 		platform_nrst_set_val(true); /* will be deasserted after attach */
+ 
+ 	bool scan_result = false;
+ 	volatile exception_s e;
+ 	TRY_CATCH (e, EXCEPTION_ALL) {
+ #if PC_HOSTED == 1
+ 		scan_result = bmda_rvswd_scan();
+ #else
+ 		scan_result = rvswd_scan();
+ #endif
+ 	}
+ 	switch (e.type) {
+ 	case EXCEPTION_TIMEOUT:
+ 		gdb_outf("Timeout during scan. Is target stuck in WFI?\n");
+ 		break;
+ 	case EXCEPTION_ERROR:
+ 		gdb_outf("Exception: %s\n", e.msg);
+ 		break;
+ 	}
+ 
+ 	if (!scan_result) {
+ 		platform_target_clk_output_enable(false);
+ 		platform_nrst_set_val(false);
+ 		gdb_out("RVSWD scan failed!\n");
+ 		return false;
+ 	}
+ 
+ 	cmd_targets(NULL, 0, NULL);
+ 	platform_target_clk_output_enable(false);
+ 	morse(NULL, false);
+ 	return true;
+ }
+ 
+
diff --git a/src/include/target.h b/src/include/target.h
index 1761080..934581d 100644
--- a/src/include/target.h
+++ b/src/include/target.h
@@ -43,6 +43,9 @@ typedef struct target_controller target_controller_s;
 #if PC_HOSTED == 1
 bool bmda_swd_scan(uint32_t targetid);
 bool bmda_jtag_scan(void);
+bool bmda_rvswd_scan(void);
+#else 
+bool rvswd_scan(void);  
 #endif
 bool adiv5_swd_scan(uint32_t targetid);
 bool jtag_scan(void);
diff --git a/src/platforms/hosted/platform.c b/src/platforms/hosted/platform.c
index 234da2a..c672cc5 100644
--- a/src/platforms/hosted/platform.c
+++ b/src/platforms/hosted/platform.c
@@ -50,9 +50,15 @@
 #include "stlinkv2.h"
 #include "ftdi_bmp.h"
 #include "jlink.h"
+#include "wchlink.h"
 #include "cmsis_dap.h"
 #endif
 
+
+#undef HOSTED_BMP_ONLY 
+#define HOSTED_BMP_ONLY  1
+#define HOSTED_WCH 1
+
 bmda_probe_s bmda_probe_info;
 
 jtag_proc_s jtag_proc;
@@ -150,6 +156,13 @@ void platform_init(int argc, char **argv)
 		break;
 #endif
 
+#ifdef HOSTED_WCH 
+	case PROBE_TYPE_WCHLINK:
+		if (!wchlink_init())
+			exit(-1);
+		break;
+#endif
+
 	default:
 		exit(1);
 	}
@@ -269,6 +282,21 @@ bool bmda_jtag_init(void)
 	}
 }
 
+bool bmda_rvswd_scan()
+{
+	bmda_probe_info.is_jtag = false;
+
+	switch (bmda_probe_info.type) {
+#ifdef HOSTED_WCH 
+	case PROBE_TYPE_WCHLINK:
+		return wchlink_rvswd_scan();
+#endif
+
+	default:
+		return false;
+	}
+}
+
 void bmda_adiv5_dp_init(adiv5_debug_port_s *const dp)
 {
 	switch (bmda_probe_info.type) {
@@ -334,6 +362,9 @@ char *bmda_adaptor_ident(void)
 	case PROBE_TYPE_JLINK:
 		return "J-Link";
 
+	case PROBE_TYPE_WCHLINK:
+		return "WCH-Link";
+
 	default:
 		return NULL;
 	}
diff --git a/src/platforms/hosted/platform.h b/src/platforms/hosted/platform.h
index 968fad1..2f4ff47 100644
--- a/src/platforms/hosted/platform.h
+++ b/src/platforms/hosted/platform.h
@@ -77,13 +77,19 @@ void platform_buffer_flush(void);
 #define VENDOR_ID_ORBCODE   0x1209U
 #define PRODUCT_ID_ORBTRACE 0x3443U
 
+#define VENDOR_ID_WCH           0x1a86U
+#define PRODUCT_ID_WCHLINK_RV   0x8010U /* WCH-Link and WCH-LinkE in mode RV */
+#define PRODUCT_ID_WCHLINK_DAP  0x8011U /* WCH-Link in mode DAP */
+#define PRODUCT_ID_WCHLINKE_DAP 0x8012U /* WCH-LinkE in mode DAP */
+
 typedef enum probe_type {
 	PROBE_TYPE_NONE = 0,
 	PROBE_TYPE_BMP,
 	PROBE_TYPE_STLINK_V2,
 	PROBE_TYPE_FTDI,
 	PROBE_TYPE_CMSIS_DAP,
-	PROBE_TYPE_JLINK
+	PROBE_TYPE_JLINK,
+	PROBE_TYPE_WCHLINK,
 } probe_type_e;
 
 void gdb_ident(char *p, int count);
diff --git a/src/target/jep106.h b/src/target/jep106.h
index c900377..1231a9d 100644
--- a/src/target/jep106.h
+++ b/src/target/jep106.h
@@ -52,6 +52,9 @@
  */
 #define ASCII_CODE_FLAG (1U << 15U) /* flag the code as legacy ASCII */
 
+/* WCH AKA Nanjing Qinheng Microelectronics */
+#define JEP106_MANUFACTURER_WCH          0x0999 // to be replaced by the real one if it exists
+
 #define JEP106_MANUFACTURER_ARM          0x43bU /* ARM Ltd. */
 #define JEP106_MANUFACTURER_FREESCALE    0x00eU /* Freescale */
 #define JEP106_MANUFACTURER_NXP          0x015U /* NXP */
diff --git a/src/target/riscv32.c b/src/target/riscv32.c
index 365126c..9135ad1 100644
--- a/src/target/riscv32.c
+++ b/src/target/riscv32.c
@@ -96,6 +96,11 @@ bool riscv32_probe(target_s *const target)
 	case JEP106_MANUFACTURER_RV_GIGADEVICE:
 		PROBE(gd32vf1_probe);
 		break;
+	case JEP106_MANUFACTURER_WCH:
+		PROBE(ch32v3xx_probe);
+		/*PROBE(ch32v003x_probe);
+		PROBE(ch32vx_probe);*/
+		break;
 	}
 
 #if PC_HOSTED == 0
diff --git a/src/target/target_probe.h b/src/target/target_probe.h
index 3e4efe5..523a521 100644
--- a/src/target/target_probe.h
+++ b/src/target/target_probe.h
@@ -96,5 +96,6 @@ bool imxrt_probe(target_s *target);
 bool zynq7_probe(target_s *target);
 
 void lpc55_dp_prepare(adiv5_debug_port_s *dp);
+bool ch32v3xx_probe(target_s *target);
 
 #endif /* TARGET_TARGET_PROBE_H */
